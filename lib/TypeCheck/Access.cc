#include <string>
#include <tuple>

#include "Pud/AST/AST.h"
#include "Pud/AST/Cache.h"
#include "Pud/Common/Common.h"
#include "Pud/Simplify/Simplify.h"
#include "Pud/TypeCheck/TypeCheck.h"

using fmt::format;

namespace Pud::AST {

/// Typecheck identifiers. If an identifier is a static variable, evaluate it
/// and replace it with its value (e.g., a @c IntExpr ). Also ensure that the
/// identifier of a generic function or a type is fully qualified (e.g., replace
/// `Ptr` with `Ptr[byte]`).
void TypecheckVisitor::visit(IdExpr* expr) {
  // Replace identifiers that have been superseded by domination analysis during
  // the simplification
  while (auto s = in(ctx->cache->replacements, expr->value))
    expr->value = s->first;

  auto val = ctx->find(expr->value);
  if (!val) {
    // Handle overloads
    if (in(ctx->cache->overloads, expr->value))
      val = ctx->force_find(get_dispatch(expr->value)->ast->name);
    seqassert(val, "cannot find '{}'", expr->value);
  }
  unify(expr->type, ctx->instantiate(val->type));

  if (val->type->is_static_type()) {
    // Evaluate static expression if possible
    expr->static_value.type = StaticValue::Type(val->type->is_static_type());
    auto s = val->type->get_static();
    seqassert(!expr->static_value.evaluated,
              "expected unevaluated expression: {}", expr->to_string());
    if (s && s->expr->static_value.evaluated) {
      // Replace the identifier with static expression
      if (s->expr->static_value.type == StaticValue::STRING)
        result_expr =
            transform(N<StringExpr>(s->expr->static_value.get_string()));
      else
        result_expr = transform(N<IntExpr>(s->expr->static_value.get_int()));
    }
    return;
  }

  if (val->is_type())
    expr->mark_type();

  // Realize a type or a function if possible and replace the identifier with
  // the fully typed identifier (e.g., `foo` -> `foo[int]`)
  if (realize(expr->type)) {
    if (!val->is_var())
      expr->value = expr->type->realized_name();
    expr->set_done();
  }
}

/// See @c transform_dot for details.
void TypecheckVisitor::visit(DotExpr* expr) {
  // Make sure to unify the current type with the transformed type
  if ((result_expr = transform_dot(expr)))
    unify(expr->type, result_expr->type);
  if (!expr->type)
    unify(expr->type, ctx->get_unbound());
}

/// Find an overload dispatch function for a given overload. If it does not
/// exist and there is more than one overload, generate it. Dispatch functions
/// ensure that a function call is being routed to the correct overload even
/// when dealing with partial functions and decorators.
/// @example This is how dispatch looks like:
///   ```def foo:dispatch(*args, **kwargs):
///        return foo(*args, **kwargs)```
auto TypecheckVisitor::get_dispatch(const std::string& fn)
    -> Type::FuncTypePtr {
  auto& overloads = ctx->cache->overloads[fn];

  // Single overload: just return it
  if (overloads.size() == 1)
    return ctx->force_find(overloads.front().name)->type->get_func();

  // Check if dispatch exists
  for (auto& m : overloads)
    if (endswith(ctx->cache->functions[m.name].ast->name, ":dispatch"))
      return ctx->cache->functions[m.name].type;

  // Dispatch does not exist. Generate it
  auto name = fn + ":dispatch";
  ExprPtr root;  // Root function name used for calling
  auto a = ctx->cache->functions[overloads[0].name].ast;
  if (!a->attributes.parent_class.empty())
    root = N<DotExpr>(N<IdExpr>(a->attributes.parent_class),
                      ctx->cache->reverse_identifier_lookup[fn]);
  else
    root = N<IdExpr>(fn);
  root = N<CallExpr>(root, N<StarExpr>(N<IdExpr>("args")),
                     N<KeywordStarExpr>(N<IdExpr>("kwargs")));
  auto ast = N<FunctionStmt>(
      name, nullptr, std::vector<Param>{Param("*args"), Param("**kwargs")},
      N<SuiteStmt>(N<ReturnStmt>(root)), Attr({"autogenerated"}));
  ctx->cache->reverse_identifier_lookup[name] =
      ctx->cache->reverse_identifier_lookup[fn];

  auto base_type = get_func_type_base(2);
  auto typ = std::make_shared<Type::FuncType>(base_type, ast.get());
  typ = std::static_pointer_cast<Type::FuncType>(
      typ->generalize(ctx->typecheck_level - 1));
  ctx->add(TypecheckItem::Func, name, typ);

  overloads.insert(overloads.begin(), {name, 0});
  ctx->cache->functions[name].ast = ast;
  ctx->cache->functions[name].type = typ;
  prepend_stmts->push_back(ast);
  return typ;
}

/// Transform a dot expression. Select the best method overload if possible.
/// @param args (optional) list of class method arguments used to select the
/// best
///             overload. nullptr if not available.
/// @example
///   `obj.__class__`   -> `type(obj)`
///   `cls.__name__`    -> `"class"` (same for functions)
///   `obj.method`      -> `cls.method(obj, ...)` or
///                        `cls.method(obj)` if method has `@property` attribute
///   @c get_class_member examples:
///   `obj.GENERIC`     -> `GENERIC` (IdExpr with generic/static value)
///   `optional.member` -> `unwrap(optional).member`
///   `pyobj.member`    -> `pyobj._getattr("member")`
/// @return nullptr if no transformation was made
/// See @c get_class_member and @c get_best_overload
auto TypecheckVisitor::transform_dot(DotExpr* expr,
                                     std::vector<CallExpr::Arg>* args)
    -> ExprPtr {
  // Special case: obj.__class__
  if (expr->member == "__class__") {
    /// TODO: prevent cls.__class__ and type(cls)
    return transform_type(NT<CallExpr>(NT<IdExpr>("type"), expr->expr));
  }

  transform(expr->expr);

  // Special case: fn.__name__
  // Should go before cls.__name__ to allow printing generic functions
  if (expr->expr->type->get_func() && expr->member == "__name__") {
    return transform(N<StringExpr>(expr->expr->type->pretty_string()));
  }
  // Special case: fn.__llvm_name__ or obj.__llvm_name__
  if (expr->member == "__llvm_name__") {
    if (realize(expr->expr->type))
      return transform(N<StringExpr>(expr->expr->type->realized_name()));
    return nullptr;
  }
  // Special case: cls.__name__
  if (expr->expr->is_type() && expr->member == "__name__") {
    if (realize(expr->expr->type))
      return transform(N<StringExpr>(expr->expr->type->pretty_string()));
    return nullptr;
  }
  // Special case: expr.__is_static__
  if (expr->member == "__is_static__") {
    if (expr->expr->is_done())
      return transform(N<BoolExpr>(expr->expr->is_static()));
    return nullptr;
  }
  // Special case: cls.__id__
  if (expr->expr->is_type() && expr->member == "__id__") {
    if (auto c = realize(expr->expr->type))
      return transform(
          N<IntExpr>(ctx->cache->classes[c->get_class()->name]
                         .realizations[c->get_class()->realized_type_name()]
                         ->id));
    return nullptr;
  }

  // Ensure that the type is known (otherwise wait until it becomes known)
  auto typ = expr->expr->get_type()->get_class();
  if (!typ)
    return nullptr;

  // Check if this is a method or member access
  if (ctx->find_method(typ.get(), expr->member).empty())
    return get_class_member(expr, args);
  auto bestMethod = get_best_overload(expr, args);

  if (args) {
    unify(expr->type, ctx->instantiate(bestMethod, typ));

    // A function is deemed virtual if it is marked as such and
    // if a base class has a RTTI
    bool isVirtual = in(ctx->cache->classes[typ->name].virtuals, expr->member);
    isVirtual &= ctx->cache->classes[typ->name].rtti;
    isVirtual &= !expr->expr->is_type();
    if (isVirtual && !bestMethod->ast->attributes.has(Attr::StaticMethod) &&
        !bestMethod->ast->attributes.has(Attr::Property)) {
      // Special case: route the call through a vtable
      if (realize(expr->type)) {
        auto fn = expr->type->get_func();
        auto vid = get_realization_id(typ.get(), fn.get());

        // Function[Tuple[TArg1, TArg2, ...], TRet]
        std::vector<ExprPtr> ids;
        for (auto& t : fn->get_arg_types())
          ids.push_back(NT<IdExpr>(t->realized_name()));
        auto fn_type = NT<InstantiateExpr>(
            NT<IdExpr>("Function"),
            std::vector<ExprPtr>{
                NT<InstantiateExpr>(NT<IdExpr>(TYPE_TUPLE), ids),
                NT<IdExpr>(fn->get_ret_type()->realized_name())});
        // Function[Tuple[TArg1, TArg2, ...],TRet](
        //    __internal__.class_get_rtti_vtable(expr)[T[VIRTUAL_ID]]
        // )
        auto e = N<CallExpr>(
            fn_type,
            N<IndexExpr>(
                N<CallExpr>(N<IdExpr>("__internal__.class_get_rtti_vtable:0"),
                            expr->expr),
                N<IntExpr>(vid)));
        return transform(e);
      }
    }
  }

  // Check if a method is a static or an instance method and transform
  // accordingly
  if (expr->expr->is_type() || args) {
    // Static access: `cls.method`
    ExprPtr e = N<IdExpr>(bestMethod->ast->name);
    unify(e->type, unify(expr->type, ctx->instantiate(bestMethod, typ)));
    return transform(e);  // Realize if needed
  } else {
    // Instance access: `obj.method`
    // Transform y.method to a partial call `type(obj).method(args, ...)`
    std::vector<ExprPtr> method_args;
    // Do not add self if a method is marked with @staticmethod
    if (!bestMethod->ast->attributes.has(Attr::StaticMethod))
      method_args.push_back(expr->expr);
    // If a method is marked with @property, just call it directly
    if (!bestMethod->ast->attributes.has(Attr::Property))
      method_args.push_back(N<EllipsisExpr>(EllipsisExpr::PARTIAL));
    auto e =
        transform(N<CallExpr>(N<IdExpr>(bestMethod->ast->name), method_args));
    unify(expr->type, e->type);
    return e;
  }
}

/// Select the requested class member.
/// @param args (optional) list of class method arguments used to select the
/// best
///             overload if the member is optional. nullptr if not available.
/// @example
///   `obj.GENERIC`     -> `GENERIC` (IdExpr with generic/static value)
///   `optional.member` -> `unwrap(optional).member`
///   `pyobj.member`    -> `pyobj._getattr("member")`
auto TypecheckVisitor::get_class_member(DotExpr* expr,
                                        std::vector<CallExpr::Arg>* args)
    -> ExprPtr {
  auto typ = expr->expr->get_type()->get_class();
  seqassert(typ, "not a class");

  // Case: object member access (`obj.member`)
  if (!expr->expr->is_type()) {
    if (auto member = ctx->find_member(typ, expr->member)) {
      unify(expr->type, ctx->instantiate(member, typ));
      if (expr->expr->is_done() && realize(expr->type))
        expr->set_done();
      return nullptr;
    }
  }

  // Case: class variable (`Cls.var`)
  if (auto cls = in(ctx->cache->classes, typ->name))
    if (auto var = in(cls->class_vars, expr->member)) {
      return transform(N<IdExpr>(*var));
    }

  // Case: special members
  if (auto mtyp = find_special_member(expr->member)) {
    unify(expr->type, mtyp);
    if (expr->expr->is_done() && realize(expr->type))
      expr->set_done();
    return nullptr;
  }

  // Case: object generic access (`obj.T`)
  Type::TypePtr generic = nullptr;
  for (auto& g : typ->generics)
    if (ctx->cache->reverse_identifier_lookup[g.name] == expr->member) {
      generic = g.type;
      break;
    }
  if (generic) {
    unify(expr->type, generic);
    if (!generic->is_static_type()) {
      expr->mark_type();
    } else {
      expr->static_value.type = StaticValue::Type(generic->is_static_type());
    }
    if (realize(expr->type)) {
      if (!generic->is_static_type()) {
        return transform(N<IdExpr>(generic->realized_name()));
      } else if (generic->get_static()->expr->static_value.type ==
                 StaticValue::STRING) {
        expr->type = nullptr;  // to prevent unify(T, Static[T]) error
        return transform(N<StringExpr>(
            generic->get_static()->expr->static_value.get_string()));
      } else {
        expr->type = nullptr;  // to prevent unify(T, Static[T]) error
        return transform(
            N<IntExpr>(generic->get_static()->expr->static_value.get_int()));
      }
    }
    return nullptr;
  }

  // Case: transform `optional.member` to `unwrap(optional).member`
  if (typ->is(TYPE_OPTIONAL)) {
    auto dot = N<DotExpr>(
        transform(N<CallExpr>(N<IdExpr>(FN_UNWRAP), expr->expr)), expr->member);
    dot->set_type(ctx->get_unbound());  // as dot is not transformed
    if (auto d = transform_dot(dot.get(), args))
      return d;
    return dot;
  }

  // Case: transform `pyobj.member` to `pyobj._getattr("member")`
  if (typ->is("pyobj")) {
    return transform(N<CallExpr>(N<DotExpr>(expr->expr, "_getattr"),
                                 N<StringExpr>(expr->member)));
  }

  // Case: transform `union.m` to `__internal__.get_union_method(union, "m",
  // ...)`
  if (typ->get_union()) {
    return transform(
        N<CallExpr>(N<IdExpr>("__internal__.get_union_method:0"),
                    std::vector<CallExpr::Arg>{
                        {"union", expr->expr},
                        {"method", N<StringExpr>(expr->member)},
                        {"", N<EllipsisExpr>(EllipsisExpr::PARTIAL)}}));
  }

  // For debugging purposes:
  // ctx->find_method(typ.get(), expr->member);
  Err(Error::DOT_NO_ATTR, expr, typ->pretty_string(), expr->member);
  return nullptr;
}

auto TypecheckVisitor::find_special_member(const std::string& member)
    -> Type::TypePtr {
  if (member == "__elemsize__")
    return ctx->get_type("int");
  if (member == "__atomic__")
    return ctx->get_type("bool");
  if (member == "__contents_atomic__")
    return ctx->get_type("bool");
  if (member == "__name__")
    return ctx->get_type("str");
  return nullptr;
}

/// Select the best overloaded function or method.
/// @param expr    a DotExpr (for methods) or an IdExpr (for overloaded
/// functions)
/// @param methods List of available methods.
/// @param args    (optional) list of class method arguments used to select the
/// best
///                overload if the member is optional. nullptr if not available.
auto TypecheckVisitor::get_best_overload(Expr* expr,
                                         std::vector<CallExpr::Arg>* args)
    -> Type::FuncTypePtr {
  // Prepare the list of method arguments if possible
  std::unique_ptr<std::vector<CallExpr::Arg>> method_args;

  if (args) {
    // Case: method overloads (DotExpr)
    bool add_self = true;
    if (auto dot = expr->get_dot()) {
      auto methods = ctx->find_method(dot->expr->type->get_class().get(),
                                      dot->member, false);
      if (!methods.empty() &&
          methods.front()->ast->attributes.has(Attr::StaticMethod))
        add_self = false;
    }

    // Case: arguments explicitly provided (by CallExpr)
    if (add_self && expr->get_dot() && !expr->get_dot()->expr->is_type()) {
      // Add `self` as the first argument
      args->insert(args->begin(), {"", expr->get_dot()->expr});
    }
    method_args = std::make_unique<std::vector<CallExpr::Arg>>();
    for (auto& a : *args)
      method_args->push_back(a);
  } else {
    // Partially deduced type thus far
    auto type_so_far =
        expr->get_type() ? expr->get_type()->get_class() : nullptr;
    if (type_so_far && type_so_far->get_func()) {
      // Case: arguments available from the previous type checking round
      method_args = std::make_unique<std::vector<CallExpr::Arg>>();
      if (expr->get_dot() && !expr->get_dot()->expr->is_type()) {  // Add `self`
        auto n = N<NoneExpr>();
        n->set_type(expr->get_dot()->expr->type);
        method_args->push_back({"", n});
      }
      for (auto& a : type_so_far->get_func()->get_arg_types()) {
        auto n = N<NoneExpr>();
        n->set_type(a);
        method_args->push_back({"", n});
      }
    }
  }

  if (method_args) {
    Type::FuncTypePtr best_method = nullptr;
    // Use the provided arguments to select the best method
    if (auto dot = expr->get_dot()) {
      // Case: method overloads (DotExpr)
      auto methods = ctx->find_method(dot->expr->type->get_class().get(),
                                      dot->member, false);
      auto m = find_matching_methods(dot->expr->type->get_class(), methods,
                                     *method_args);
      best_method = m.empty() ? nullptr : m[0];
    } else if (auto id = expr->get_id()) {
      // Case: function overloads (IdExpr)
      std::vector<Type::FuncTypePtr> methods;
      for (auto& m : ctx->cache->overloads[id->value])
        if (!endswith(m.name, ":dispatch"))
          methods.push_back(ctx->cache->functions[m.name].type);
      std::reverse(methods.begin(), methods.end());
      auto m = find_matching_methods(nullptr, methods, *method_args);
      best_method = m.empty() ? nullptr : m[0];
    }
    if (best_method)
      return best_method;
  } else {
    // If overload is ambiguous, route through a dispatch function
    std::string name;
    if (auto dot = expr->get_dot()) {
      name = ctx->cache->get_method(dot->expr->type->get_class(), dot->member);
    } else {
      name = expr->get_id()->value;
    }
    return get_dispatch(name);
  }

  // Print a nice error message
  std::string args_nice;
  if (method_args) {
    std::vector<std::string> a;
    for (auto& t : *method_args)
      a.emplace_back(fmt::format("{}", t.value->type->pretty_string()));
    args_nice = fmt::format("({})", fmt::join(a, ", "));
  }

  if (auto dot = expr->get_dot()) {
    Err(Error::DOT_NO_ATTR_ARGS, expr, dot->expr->type->pretty_string(),
        dot->member, args_nice);
  } else {
    Err(Error::FN_NO_ATTR_ARGS, expr, ctx->cache->rev(expr->get_id()->value),
        args_nice);
  }

  return nullptr;
}

}  // namespace Pud::AST